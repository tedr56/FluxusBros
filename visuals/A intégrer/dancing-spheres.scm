(require mzlib/string)
;(clear)
(define dancing-sphere (build-sphere 16 16))
(grab dancing-sphere)(hide 1)(ungrab)
(define-struct dsphere (pos (size #:mutable) color opa))
(define-struct dspheres (dspheres) #:mutable)

(define ds (make-dspheres (list (make-dsphere (vector 0 0 0) (vector 1 1 1) (vector 0 0 0) 0.2))))

(define (dancing-spheres chann cross)
    (define (get-sens i size sizep cpt)
        (let ((rndX (* (+ (vector-ref (dsphere-pos (list-ref (dspheres-dspheres ds) i)) 0)
                          (* 0.5 (vector-ref size 0))
                          (* 0.5 (vector-ref sizep 0)))
                       (* 2 (- (round (flxrnd)) 1))))
              (rndY (* (+ (vector-ref (dsphere-pos (list-ref (dspheres-dspheres ds) i)) 1)
                          (* 0.5 (vector-ref size 1))
                          (* 0.5 (vector-ref sizep 0)))
                       (* 2 (- (round (flxrnd)) 1)))))
;    (show rndX)
;    (show rndY)

        (if (> (vmag
                    (vadd
                        (dsphere-pos (list-ref (dspheres-dspheres ds) i))
                        (vector rndX rndY 0)
                    )
                )
                (mn chann 45 30))
            (when (< cpt 20) (get-sens i size sizep (add1 cpt)))
            (vector rndX rndY 0)
        )
        )
    )

    (let ((g (* (mn chann 8) (m chann 9))))
    (blur (mn chann 10))
;    (blur (+ 0.1 (- 1 (* 0.0001 (gh2 2 g)))))
    (flxseed (gh2 1 g))
;    (hint-ignore-depth)
    (hint-depth-sort)
    (blend-mode 'src-alpha 'dst-alpha)

    (rotate (vector (* 60 (cos (* 1.5 (time)))) (* 60 (sin (* 2 (time)))) (* 10 (time))))
    (for ((i (build-list (length (dspheres-dspheres ds)) values))
            #:when (< i (length (dspheres-dspheres ds))))
        (let ((cube (list-ref (dspheres-dspheres ds) i))
              (cubep (unless (zero? i) (list-ref (dspheres-dspheres ds) (sub1 i))))
              (cube0 (list-ref (dspheres-dspheres ds) 0)))
            (push)
                (translate (vadd (dsphere-pos cube) (vector 0 0 (* -0.1 (vector-ref (dsphere-size cube) 0)))))
;                (colour (vector 1 0.5 0.3))
                (opacity (max2 (dsphere-opa cube) (opa-cross (mn 0 cross))))
                (colour (vmul (dsphere-color cube) (mn chann 16)))
                (scale (dsphere-size cube))
                (draw-instance dancing-sphere)
            (pop)
        )
    )

    (let ((max-cubes (+ (inexact->exact (floor (mn chann 40 100))) 1)))
;(show (length (dspheres-dspheres ds)))
        (when (> (length (dspheres-dspheres ds)) max-cubes)
            #(for ((i (build-list (- (length (dspheres-dspheres ds)) max-cubes) values)))
                (destroy (dsphere-prim (list-ref (dspheres-dspheres ds) i)))
            )
            (set-dspheres-dspheres! ds (list-tail (dspheres-dspheres ds) (- (length (dspheres-dspheres ds)) max-cubes)))
        )
    )

    (for ((i (build-list 15 (lambda (x) (+ x 1))))
            #:when (> (gh2 i g) (mn chann 47 10)))
        (let* ((cubep (sub1 (length (dspheres-dspheres ds))))
               (color (vmul (vector (gh2 i g) (gh2 5 g) (gh2 12 g)) (mn chann 16)))
;               (opa (+ 0.2 (* (gh2 i g) 0.0001)))
(opa 1)
               (size (vmul (vector (gh2 i g) (gh2 (+ 0 i) g) (gh2 (+ 5 i) g)) (mn chann 46 0.001)))
               (sizep (dsphere-size (list-ref (dspheres-dspheres ds) (sub1 (length (dspheres-dspheres ds))))))
               (sens (get-sens cubep size sizep 0))
;               (place (vadd (dsphere-pos (list-ref (dspheres-dspheres ds) (sub1 (length (dspheres-dspheres ds)))))
;                            sens))
               (place (unless (void? sens)(vadd
                        (dsphere-pos (list-ref (dspheres-dspheres ds) cubep))
                        sens
                   )))
              )
            (unless (void? sens)
                (set-dspheres-dspheres! ds (append (dspheres-dspheres ds) (list (make-dsphere place size color opa))))
            )
        )
    )
)
)

(define dancing-spheres-state 0)
(define dancing-spheres-stop 0)

(define (dancing-spheres-control chann cross in)
    (when (not (zero? (pipe-content-length in)))
        (let ((data (read in)))
            (if (equal? "1" data)
                (set! dancing-spheres-stop 1)
                (set! dancing-spheres-stop 0)
            )
        )
    )
    (cond ((and (= dancing-spheres-state 0) (> (m 0 cross) 0) (zero? dancing-spheres-stop))
        (set! dancing-spheres-state 1)
        (spawn-task (lambda () (dancing-spheres chann cross)) 'dancing-spheres)))
    (cond ((or (and (= dancing-spheres-state 1) (= (m 0 cross) 0)) (not (zero? dancing-spheres-stop)))
        (set! dancing-spheres-state 0)
        (rm-task 'dancing-spheres)))
)
